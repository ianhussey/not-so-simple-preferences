---
title: "Download data and anonymise"
author: Jamie Cummins
format: html
date: today
output:
  html_document:
    code_folding: hide
    highlight: haddock
    theme: flatly
    toc: yes
    toc_float: yes
---

```{r include=FALSE}

knitr::opts_chunk$set(message = FALSE, 
                      warning = FALSE)

options(scipen=999)

```

# Dependencies

```{r}

library(Hmisc)
library(RSQLite)
library(jsonlite)
library(tidyverse)
library(janitor)
library(pacman)
library(knitr)
library(kableExtra)
library(lubridate) 
library(RCurl)
library(threadr)

```

# Read in sqlite data from server

## Set directories

```{r}

# access secure password and site directory variables
site_directory <- Sys.getenv("SITE_DIRECTORY")
site_password <- Sys.getenv("SITE_PASS")

# specify directory for downloads
download_folder <- '../../data/raw/'

# specify exact locations
download_location <- paste0(download_folder, "data_raw.sqlite") # included in .gitignore so that it isnt shared publicly


# specify data to be downloaded and login credentials
url <- paste0(site_directory, "ih/not-so-simple-preferences/data/data.sqlite")
credentials <- site_password


# download questionnaire data and save it to location
download_ftp_file(file_remote = url,
                  file_local = download_location,
                  credentials = credentials)

```

## Establish connection with SQL server

```{r}

# Establish SQL connection to database
con <-
  dbConnect(drv = RSQLite::SQLite(),
            dbname = download_location)


# Extract main table
full_data <-
  dbGetQuery(conn = con,
             statement = 'SELECT * FROM labjs')

# Close and discard connection
dbDisconnect(conn = con)
rm(con)

```

## Code for parsing of sqlite files

Defines various functions to be used when extracting data

```{r}

# count the number of characters needed to ensure identifiers are unique
count_unique <- function(x) {
  return(length(unique(x)))
}

information_preserved <- function(x, length) {
  return(count_unique(str_sub(x, end = i)) == count_unique(x))
}

for (i in 5:36) {
  if (
    information_preserved(d$session, i) &&
    information_preserved(d$observation, i)
  ) {
    break()
  }
}

# data extraction function
parseJSON <- function(input) {
  return(input |>
           fromJSON(flatten = TRUE) %>% {
             if (class(.) == 'list') {discard(., is.null) |> as_tibble()}
             else {.}
             } |>
           janitor::clean_names() |>
           mutate_all(as.character))
}

```

## Do extraction and processing

```{r}

# extract meta-data
meta_data <-
  map_dfr(full_data$metadata, fromJSON) |> # apply JSON function to the metadata
  rename(unique_id = id) # rename to avoid confusion

# add extracted meta-data to dataframe
main_data <- full_data |>
  bind_cols(meta_data) |>
  select(-metadata) |>
  mutate(
    session = str_sub(session, end = i),
    unique_id = str_sub(unique_id, end = i)
    )

# get incremental data
full_raw_data_temp <- main_data |>
  filter(payload %in% c('incremental', 'latest')) |>
  group_by(unique_id, id) %>%
  do(
    {map_dfr(.$data, parseJSON)} |>
      bind_rows()
  ) |>
  ungroup()

# get full data, add participant identifier to every row
full_raw_data <- full_raw_data_temp |>
  group_by(unique_id) |>
  fill(unique_id, .direction = "downup") |>
  ungroup()

# add completeness
data_raw_flattened <- full_raw_data |>
  count(prolific_id, unique_id, name = "n_rows_per_unique_id") |>
  mutate(completeness_check = if_else(n_rows_per_unique_id==17, "passed", "failed")) |>
  left_join(full_raw_data, by = join_by(prolific_id, unique_id))

data_raw_flattened |>
  count(prolific_id, unique_id, name = "n_rows_per_unique_id") |>
  count(n_rows_per_unique_id, name = "frequency")

write_rds(data_raw_flattened, "../../data/raw/data_raw_flattened.rds") # included in .gitignore so that it isnt shared publicly
# data_raw_flattened <- read_rds("../../data/raw/data_raw_flattened.rds")

```

# Compare with prolific payment records

```{r}

data_prolific <- read.csv("../../data/raw/data_raw_prolific_export.csv") |>
  select(prolific_id = Participant.id,
         age_prolific = Age,
         sex_prolific = Sex,
         ethnicity_prolific = Ethnicity.simplified,
         country_prolific = Country.of.residence,
         completion_time_prolific = Time.taken) 

data_raw_flattened_prolificdata <- 
  full_join(data_raw_flattened, 
            data_prolific,
            by = join_by(prolific_id))

write_rds(data_raw_flattened_prolificdata, "../../data/raw/data_raw_flattened_prolificdata.rds") # included in .gitignore so that it isnt shared publicly
# data_raw_flattened_prolificdata <- read_rds("../../data/raw/data_raw_flattened_prolificdata.rds")

```

# Do anonymisation

```{r}

# identify the distinct participant identities
data_raw_flattened_prolificdata_anonymised <- data_raw_flattened_prolificdata |>
  select(-prolific_id)
  
write_rds(data_raw_flattened_prolificdata_anonymised, "../../data/raw/data_raw_flattened_prolificdata_anonymised.rds")
  
```
